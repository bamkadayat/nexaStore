generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * USER & AUTHENTICATION
 */

model User {
  id            String  @id @default(uuid())
  email         String  @unique
  password      String
  name          String
  role          Role    @default(USER)
  emailVerified Boolean @default(false)
  isActive      Boolean @default(true)

  // Relations
  cart      Cart?
  orders    Order[]
  addresses Address[]
  reviews   Review[]
  wishlist  Wishlist?

  // Timestamps
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  lastLoginAt  DateTime?
  Subscription Subscription[]

  @@index([email])
  @@map("users")
}

/**
 * USER ROLE
 */
enum Role {
  USER
  ADMIN
}

/**
 * VERIFICATION CODE (for email verification with 4-digit PIN)
 */
model VerificationCode {
  id        String   @id @default(uuid())
  email     String
  code      String // 4-digit PIN
  purpose   VerificationPurpose // LOGIN, SIGNUP, RESET_PASSWORD
  expiresAt DateTime
  verified  Boolean  @default(false)

  // Timestamps
  createdAt DateTime @default(now())

  @@index([email, code])
  @@index([expiresAt])
  @@map("verification_codes")
}

enum VerificationPurpose {
  LOGIN
  SIGNUP
  RESET_PASSWORD
}

/**
 * PRODUCTS
 */
model Product {
  id           String   @id @default(uuid())
  name         String
  slug         String   @unique
  description  String   @db.Text
  price        Decimal  @db.Decimal(10, 2)
  comparePrice Decimal? @db.Decimal(10, 2) // Original price for discounts
  costPrice    Decimal? @db.Decimal(10, 2) // For profit calculations
  sku          String?  @unique
  barcode      String?

  // Inventory
  stock             Int     @default(0)
  lowStockThreshold Int     @default(10)
  trackInventory    Boolean @default(true)

  // Categorization
  category String
  brand    String?
  tags     String[]

  // Media
  images    String[] // Array of image URLs
  thumbnail String? // Main thumbnail

  // SEO
  metaTitle       String?
  metaDescription String?

  // Status
  isActive   Boolean @default(true)
  isFeatured Boolean @default(false)

  // ============================================
  // COFFEE-SPECIFIC FIELDS
  // ============================================

  // Coffee Origin & Type
  coffeeOrigin     String? // "Ethiopia", "Colombia", etc.
  region           String? // "Yirgacheffe", "Huila", etc.
  roastLevel       RoastLevel?
  roastDate        DateTime? // When this batch was roasted
  processingMethod String? // "Washed", "Natural", "Honey", "Anaerobic"

  // Coffee Characteristics
  flavorNotes  String[] // ["chocolate", "berry", "caramel", "floral"]
  tastingNotes String?  @db.Text // Detailed tasting description
  altitude     String? // "1500-2000m"
  varietals    String[] // ["Arabica", "Bourbon", "Typica"]
  harvestYear  Int? // 2024

  // Certifications & Ethics
  certifications String[] // ["Organic", "Fair Trade", "Rainforest Alliance"]
  farmName       String? // Name of the coffee farm
  farmerStory    String?  @db.Text // Story behind the coffee

  // Coffee Ratings (1-5 scale)
  acidityLevel   Int? // 1=Low, 5=High
  bodyLevel      Int? // 1=Light, 5=Full
  sweetnessLevel Int? // 1=Low, 5=High

  // Brewing Information
  bestBrewMethods String[] // ["Pour-over", "French Press", "Espresso"]
  grindSize       String? // "Fine", "Medium", "Coarse"
  brewTemperature String? // "90-96Â°C"
  brewRatio       String? // "1:15" or "1:16"

  // Product Type
  productType ProductType @default(COFFEE_BEANS)
  weight      Int? // Weight in grams (250, 500, 1000)

  // Equipment-specific (for brewing gear)
  material      String? // "Stainless Steel", "Ceramic", "Glass"
  capacity      String? // "1L", "500ml", "6 cups"
  compatibility String[] // ["V60", "Chemex", "All methods"]

  // Relations
  cartItems     CartItem[]
  orderItems    OrderItem[]
  reviews       Review[]
  wishlistItems WishlistItem[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([slug])
  @@index([name])
  @@index([isActive, isFeatured])
  @@index([roastLevel])
  @@index([coffeeOrigin])
  @@index([productType])
  @@map("products")
}

/**
 * PRODUCT TYPE ENUM
 */
enum ProductType {
  COFFEE_BEANS // Whole bean or ground coffee
  BREWING_EQUIPMENT // Pour-over, french press, etc.
  ACCESSORIES // Filters, scales, etc.
  MERCHANDISE // Mugs, books, etc.
}

/**
 * ROAST LEVEL ENUM
 */
enum RoastLevel {
  LIGHT // Light roast (Nordic style)
  MEDIUM_LIGHT // Medium-light
  MEDIUM // Medium roast
  MEDIUM_DARK // Medium-dark
  DARK // Dark roast (French/Italian)
}

/**
 * CART
 */
model Cart {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  items CartItem[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("carts")
}

/**
 * CART ITEMS
 */
model CartItem {
  id        String  @id @default(uuid())
  cartId    String
  cart      Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  quantity  Int     @default(1)

  // Optional: Selected grind size (if coffee beans)
  grindPreference String? // "Whole Bean", "Fine", "Medium", "Coarse"

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
  @@map("cart_items")
}

/**
 * ORDERS
 */
model Order {
  id          String @id @default(uuid())
  orderNumber String @unique
  userId      String
  user        User   @relation(fields: [userId], references: [id])

  // Order Details
  items        OrderItem[]
  subtotal     Decimal     @db.Decimal(10, 2)
  tax          Decimal     @default(0) @db.Decimal(10, 2)
  shippingCost Decimal     @default(0) @db.Decimal(10, 2)
  discount     Decimal     @default(0) @db.Decimal(10, 2)
  total        Decimal     @db.Decimal(10, 2)

  // Status
  status        OrderStatus   @default(PENDING)
  paymentStatus PaymentStatus @default(PENDING)

  // Payment
  paymentMethod   String? // card, bank_transfer, etc.
  paymentIntentId String? @unique // Stripe payment intent ID

  // Shipping
  shippingAddress Json // Store as JSON for flexibility
  billingAddress  Json? // Optional separate billing address
  trackingNumber  String?
  shippingCarrier String?

  // Notes
  customerNote String? @db.Text
  internalNote String? @db.Text // Admin notes

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  paidAt      DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?
  cancelledAt DateTime?

  @@index([userId])
  @@index([orderNumber])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

enum OrderStatus {
  PENDING // Order created, awaiting payment
  PAID // Payment received
  PROCESSING // Order being prepared
  SHIPPED // Order shipped
  DELIVERED // Order delivered
  CANCELLED // Order cancelled
  REFUNDED // Order refunded
}

enum PaymentStatus {
  PENDING // Awaiting payment
  PAID // Payment successful
  FAILED // Payment failed
  REFUNDED // Payment refunded
  PARTIALLY_REFUNDED // Partial refund
}

/**
 * ORDER ITEMS
 */
model OrderItem {
  id        String  @id @default(uuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id])

  // Snapshot of product at time of order
  productName  String
  productImage String?
  sku          String?

  // Coffee-specific snapshot
  roastLevel      String? // Snapshot of roast level
  grindPreference String? // Customer's grind choice

  // Pricing
  quantity Int
  price    Decimal @db.Decimal(10, 2) // Price at time of order
  subtotal Decimal @db.Decimal(10, 2) // quantity * price

  // Timestamps
  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

/**
 * ADDRESSES
 */
model Address {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Address fields
  fullName     String
  company      String?
  addressLine1 String
  addressLine2 String?
  city         String
  state        String?
  postalCode   String
  country      String  @default("Norway")
  phone        String

  // Flags
  isDefault Boolean     @default(false)
  type      AddressType @default(SHIPPING)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("addresses")
}

enum AddressType {
  SHIPPING
  BILLING
  BOTH
}

/**
 * REVIEWS
 */
model Review {
  id        String  @id @default(uuid())
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Review content
  rating  Int // 1-5 stars
  title   String?
  comment String  @db.Text

  // Coffee-specific review fields
  tasteRating Int? // 1-5 stars (how good it tastes)
  aromaRating Int? // 1-5 stars (aroma quality)
  valueRating Int? // 1-5 stars (value for money)
  brewMethod  String? // How they brewed it

  // Status
  isVerifiedPurchase Boolean @default(false)
  isApproved         Boolean @default(false) // Admin approval

  // Helpful votes
  helpfulCount Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, productId]) // One review per user per product
  @@index([productId])
  @@index([rating])
  @@map("reviews")
}

/**
 * WISHLIST
 */
model Wishlist {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  items WishlistItem[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("wishlists")
}

/**
 * WISHLIST ITEMS
 */
model WishlistItem {
  id         String   @id @default(uuid())
  wishlistId String
  wishlist   Wishlist @relation(fields: [wishlistId], references: [id], onDelete: Cascade)
  productId  String
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Optional: Notify when back in stock
  notifyWhenAvailable Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())

  @@unique([wishlistId, productId])
  @@index([wishlistId])
  @@index([productId])
  @@map("wishlist_items")
}

/**
 * CATEGORIES
 */
model Category {
  id          String     @id @default(uuid())
  name        String     @unique
  slug        String     @unique
  description String?    @db.Text
  image       String?
  parentId    String?
  parent      Category?  @relation("CategoryToCategory", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryToCategory")

  // SEO
  metaTitle       String?
  metaDescription String?

  // Display
  displayOrder Int     @default(0)
  isActive     Boolean @default(true)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([parentId])
  @@map("categories")
}

/**
 * SUBSCRIPTIONS (Optional - for future coffee subscriptions)
 */
model Subscription {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Subscription details
  planName  String // "Weekly Fresh Roast", "Monthly Essentials"
  frequency SubscriptionFreq   @default(MONTHLY)
  status    SubscriptionStatus @default(ACTIVE)

  // Preferences
  roastPreference RoastLevel?
  grindPreference String? // "Whole Bean", "Medium", etc.
  quantity        Int         @default(250) // Grams per delivery

  // Pricing
  price Decimal @db.Decimal(10, 2)

  // Stripe
  stripeSubscriptionId String? @unique
  stripeCustomerId     String?

  // Delivery
  nextDeliveryDate DateTime?
  lastDeliveryDate DateTime?

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  startedAt   DateTime  @default(now())
  pausedAt    DateTime?
  cancelledAt DateTime?

  @@index([userId])
  @@index([status])
  @@map("subscriptions")
}

enum SubscriptionFreq {
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELLED
  EXPIRED
}
